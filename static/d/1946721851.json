{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"friendlyName":"Branch and Bound on Cost","solverKey":"branchAndBoundOnCost","type":"algorithm","class":"exhaustive","defaults":{"showBestPath":false,"evaluatingDetailLevel":2,"maxEvaluatingDetailLevel":2}},"html":"<h1>Branch and Bound on Cost</h1>\n<p>This is a recursive algorithm, similar to depth first search, that is guarunteed to find the optimal solution.</p>\n<p>The candidate solution space is generated by systematically traversing possible paths, and discarding large subsets of fruitless candidates by comparing the current solution to an upper and lower bound. In this case, the upper bound is the best path found so far.</p>\n<p>While evaluating paths, if at any point the current solution is already more expensive (longer) than the best complete path discovered, there is no point continuing.</p>\n<p>For example, imagine a solution <code class=\"language-text\">A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; A</code> was already found with a cost of 100.</p>\n<p>If during our search, we are evaluating <code class=\"language-text\">A -&gt; C -&gt; E</code>, which has a cost of 110, there is no point evaluating the remaining solutions.</p>\n<p>Instead of continuing to evaluate all of the child solutions from here, we can go down a different path, eliminating candidates not worth evaluating:</p>\n<p><code class=\"language-text\">A -&gt; C -&gt; E -&gt; D -&gt; B -&gt; A</code></p>\n<p><code class=\"language-text\">A -&gt; C -&gt; E -&gt; B -&gt; D -&gt; A</code></p>\n<h2>The code</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">branchAndBoundOnCost</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">points<span class=\"token punctuation\">,</span> path<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> visited<span class=\"token operator\">=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> overallBest<span class=\"token operator\">=</span><span class=\"token number\">Infinity</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>visited <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// initial call</span>\n    path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>points<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    points <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    visited <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> available <span class=\"token operator\">=</span> <span class=\"token function\">setDifference</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">,</span> visited<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> backToStart <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>path<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> cost <span class=\"token operator\">=</span> <span class=\"token function\">pathCost</span><span class=\"token punctuation\">(</span>backToStart<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cost <span class=\"token operator\">></span> overallBest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// cut this branch</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>available<span class=\"token punctuation\">.</span>size <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// at the end of a branch</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>cost<span class=\"token punctuation\">,</span> backToStart<span class=\"token punctuation\">]</span> \n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>bestCost<span class=\"token punctuation\">,</span> bestPath<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> p <span class=\"token keyword\">of</span> available<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    visited<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// recurse</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>curCost<span class=\"token punctuation\">,</span> curPath<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">branchAndBoundOnCost</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">,</span> visited<span class=\"token punctuation\">,</span> overallBest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curCost <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bestCost <span class=\"token operator\">||</span> curCost <span class=\"token operator\">&lt;</span> bestCost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">[</span>bestCost<span class=\"token punctuation\">,</span> bestPath<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>curCost<span class=\"token punctuation\">,</span> curPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>overallBest <span class=\"token operator\">||</span> bestCost <span class=\"token operator\">&lt;</span> overallBest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        overallBest <span class=\"token operator\">=</span> bestCost\n        self<span class=\"token punctuation\">.</span><span class=\"token function\">setBestPath</span><span class=\"token punctuation\">(</span>bestPath<span class=\"token punctuation\">,</span> bestCost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    visited<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>bestCost<span class=\"token punctuation\">,</span> bestPath<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>"}},{"node":{"frontmatter":{"friendlyName":"Depth First Search (Brute Force)","solverKey":"depthFirstSearch","type":"algorithm","class":"exhaustive","defaults":{"showBestPath":false,"evaluatingDetailLevel":2,"maxEvaluatingDetailLevel":2}},"html":"<p>When deploying a set of services using docker-compose, it’s a good idea to have a separate repository to avoid cloning all of the code into your production environment.</p>\n<p>I finally got <a href=\"https://www.term.ninja\">termninja</a> set up correctly with continuous integration and docker-compose on digital ocean, and I thought I’d document the setup.</p>\n<h2>Production repository</h2>\n<p>A typical docker-compose project has a <code class=\"language-text\">docker-compose.yml</code> at the root of the project, and all of the code for the images as subfolders.</p>\n<p>[development folder structure]</p>\n<p>This works great for development - it’s easy to set up volumes and edit the code alongside the images. In production, however, it doesn’t make sense to clone the entire repository just to get to the docker-compose.yml file and start services.</p>\n<p>The solution I prefer is to have a separate repository set-up, in this case termninja-docker, that contains only the docker-compose.yml and any production specific configuration.</p>\n<p>[production folder structure]</p>\n<h2>Deployment</h2>\n<p>With this structure in place, deployments are accomplished using a container registry (like <a href=\"docker.com/hub\">docker hub</a>). It’s free to use for public images, and easy to push with docker-compose.</p>\n<p>The docker-compose.yml in both the development repo and the production repo should be setup to track the container registry.</p>\n<p>[tagged docker-compose]</p>\n<h2>Building and pushing images</h2>\n<p>Once the docker-compose.yml file is setup to track the appropriate image from the container registry, building images is simple.</p>\n<p><code class=\"language-text\">docker-compose build [service-name]</code></p>\n<p>Pushing the updated image is equally simple</p>\n<p><code class=\"language-text\">docker-compose push [service-name]</code></p>\n<h2>Pulling latest images</h2>\n<p>From the production environment, once the production docker-compose.yml is setup to track the container registry images, updating is simple</p>\n<p><code class=\"language-text\">docker-compose down</code>\n<code class=\"language-text\">docker-compose pull [service-name]</code>\n<code class=\"language-text\">docker-compose up</code></p>\n<p>All of this seems very intuitive, but I’ve come across several projects where deployments are setup to:\nclone the development repo\nbuild and start images</p>\n<p>This process is time consuming (more downtime) and results in unnecessary code residing on the server.</p>\n<h2>Continuous integration</h2>\n<p>Once this process is in place, I recommend setting up continuous integration to perform these functions automatically on every commit to the master branch in the development repo. </p>\n<p>A simplified travis-ci configuration from <a href=\"https://www.term.ninja\">termninja</a> is below. It performs the following steps on every commit.</p>\n<ol>\n<li>Clone the repository (automatic for travis)</li>\n<li>Login to docker hub using credentials provided through the <a href=\"https://www.travis-ci.com/environment\">travis environment</a> - <code class=\"language-text\">docker login</code></li>\n<li>Build the services - <code class=\"language-text\">docker-compose build games api</code></li>\n<li>Push the images - <code class=\"language-text\">docker-compose push games api</code></li>\n<li>Decrypt private production SSH key*</li>\n<li>SSH to production environmnet</li>\n<li>Stop services - <code class=\"language-text\">docker-compose down</code></li>\n<li>Pull updated images - <code class=\"language-text\">docker-compose pull games api</code></li>\n<li>Start service - <code class=\"language-text\">docker-compose up</code></li>\n</ol>\n<p>[travis-ci.yml]</p>\n<p>*Note that the ssh keys for the production server must be <a href=\"https://travis-ci.com/ssh-keys\">encrypted</a>.</p>\n<p>Hopefully this helps someone else as there was less documentation out there than I expected when setting this up. Let me know how it goes below, thanks!</p>"}},{"node":{"frontmatter":{"friendlyName":"Random","solverKey":"random","type":"algorithm","class":"exhaustive","defaults":{"showBestPath":false,"evaluatingDetailLevel":1,"maxEvaluatingDetailLevel":1}},"html":"<p>When deploying a set of services using docker-compose, it’s a good idea to have a separate repository to avoid cloning all of the code into your production environment.</p>\n<p>I finally got <a href=\"https://www.term.ninja\">termninja</a> set up correctly with continuous integration and docker-compose on digital ocean, and I thought I’d document the setup.</p>\n<h2>Production repository</h2>\n<p>A typical docker-compose project has a <code class=\"language-text\">docker-compose.yml</code> at the root of the project, and all of the code for the images as subfolders.</p>\n<p>[development folder structure]</p>\n<p>This works great for development - it’s easy to set up volumes and edit the code alongside the images. In production, however, it doesn’t make sense to clone the entire repository just to get to the docker-compose.yml file and start services.</p>\n<p>The solution I prefer is to have a separate repository set-up, in this case termninja-docker, that contains only the docker-compose.yml and any production specific configuration.</p>\n<p>[production folder structure]</p>\n<h2>Deployment</h2>\n<p>With this structure in place, deployments are accomplished using a container registry (like <a href=\"docker.com/hub\">docker hub</a>). It’s free to use for public images, and easy to push with docker-compose.</p>\n<p>The docker-compose.yml in both the development repo and the production repo should be setup to track the container registry.</p>\n<p>[tagged docker-compose]</p>\n<h2>Building and pushing images</h2>\n<p>Once the docker-compose.yml file is setup to track the appropriate image from the container registry, building images is simple.</p>\n<p><code class=\"language-text\">docker-compose build [service-name]</code></p>\n<p>Pushing the updated image is equally simple</p>\n<p><code class=\"language-text\">docker-compose push [service-name]</code></p>\n<h2>Pulling latest images</h2>\n<p>From the production environment, once the production docker-compose.yml is setup to track the container registry images, updating is simple</p>\n<p><code class=\"language-text\">docker-compose down</code>\n<code class=\"language-text\">docker-compose pull [service-name]</code>\n<code class=\"language-text\">docker-compose up</code></p>\n<p>All of this seems very intuitive, but I’ve come across several projects where deployments are setup to:\nclone the development repo\nbuild and start images</p>\n<p>This process is time consuming (more downtime) and results in unnecessary code residing on the server.</p>\n<h2>Continuous integration</h2>\n<p>Once this process is in place, I recommend setting up continuous integration to perform these functions automatically on every commit to the master branch in the development repo. </p>\n<p>A simplified travis-ci configuration from <a href=\"https://www.term.ninja\">termninja</a> is below. It performs the following steps on every commit.</p>\n<ol>\n<li>Clone the repository (automatic for travis)</li>\n<li>Login to docker hub using credentials provided through the <a href=\"https://www.travis-ci.com/environment\">travis environment</a> - <code class=\"language-text\">docker login</code></li>\n<li>Build the services - <code class=\"language-text\">docker-compose build games api</code></li>\n<li>Push the images - <code class=\"language-text\">docker-compose push games api</code></li>\n<li>Decrypt private production SSH key*</li>\n<li>SSH to production environmnet</li>\n<li>Stop services - <code class=\"language-text\">docker-compose down</code></li>\n<li>Pull updated images - <code class=\"language-text\">docker-compose pull games api</code></li>\n<li>Start service - <code class=\"language-text\">docker-compose up</code></li>\n</ol>\n<p>[travis-ci.yml]</p>\n<p>*Note that the ssh keys for the production server must be <a href=\"https://travis-ci.com/ssh-keys\">encrypted</a>.</p>\n<p>Hopefully this helps someone else as there was less documentation out there than I expected when setting this up. Let me know how it goes below, thanks!</p>"}},{"node":{"frontmatter":{"friendlyName":"Shortest Path","solverKey":"shortestPath","type":"algorithm","class":"heuristic","defaults":{"showBestPath":true,"evaluatingDetailLevel":1,"maxEvaluatingDetailLevel":1}},"html":"<p>When deploying a set of services using docker-compose, it’s a good idea to have a separate repository to avoid cloning all of the code into your production environment.</p>\n<p>I finally got <a href=\"https://www.term.ninja\">termninja</a> set up correctly with continuous integration and docker-compose on digital ocean, and I thought I’d document the setup.</p>\n<h2>Production repository</h2>\n<p>A typical docker-compose project has a <code class=\"language-text\">docker-compose.yml</code> at the root of the project, and all of the code for the images as subfolders.</p>\n<p>[development folder structure]</p>\n<p>This works great for development - it’s easy to set up volumes and edit the code alongside the images. In production, however, it doesn’t make sense to clone the entire repository just to get to the docker-compose.yml file and start services.</p>\n<p>The solution I prefer is to have a separate repository set-up, in this case termninja-docker, that contains only the docker-compose.yml and any production specific configuration.</p>\n<p>[production folder structure]</p>\n<h2>Deployment</h2>\n<p>With this structure in place, deployments are accomplished using a container registry (like <a href=\"docker.com/hub\">docker hub</a>). It’s free to use for public images, and easy to push with docker-compose.</p>\n<p>The docker-compose.yml in both the development repo and the production repo should be setup to track the container registry.</p>\n<p>[tagged docker-compose]</p>\n<h2>Building and pushing images</h2>\n<p>Once the docker-compose.yml file is setup to track the appropriate image from the container registry, building images is simple.</p>\n<p><code class=\"language-text\">docker-compose build [service-name]</code></p>\n<p>Pushing the updated image is equally simple</p>\n<p><code class=\"language-text\">docker-compose push [service-name]</code></p>\n<h2>Pulling latest images</h2>\n<p>From the production environment, once the production docker-compose.yml is setup to track the container registry images, updating is simple</p>\n<p><code class=\"language-text\">docker-compose down</code>\n<code class=\"language-text\">docker-compose pull [service-name]</code>\n<code class=\"language-text\">docker-compose up</code></p>\n<p>All of this seems very intuitive, but I’ve come across several projects where deployments are setup to:\nclone the development repo\nbuild and start images</p>\n<p>This process is time consuming (more downtime) and results in unnecessary code residing on the server.</p>\n<h2>Continuous integration</h2>\n<p>Once this process is in place, I recommend setting up continuous integration to perform these functions automatically on every commit to the master branch in the development repo. </p>\n<p>A simplified travis-ci configuration from <a href=\"https://www.term.ninja\">termninja</a> is below. It performs the following steps on every commit.</p>\n<ol>\n<li>Clone the repository (automatic for travis)</li>\n<li>Login to docker hub using credentials provided through the <a href=\"https://www.travis-ci.com/environment\">travis environment</a> - <code class=\"language-text\">docker login</code></li>\n<li>Build the services - <code class=\"language-text\">docker-compose build games api</code></li>\n<li>Push the images - <code class=\"language-text\">docker-compose push games api</code></li>\n<li>Decrypt private production SSH key*</li>\n<li>SSH to production environmnet</li>\n<li>Stop services - <code class=\"language-text\">docker-compose down</code></li>\n<li>Pull updated images - <code class=\"language-text\">docker-compose pull games api</code></li>\n<li>Start service - <code class=\"language-text\">docker-compose up</code></li>\n</ol>\n<p>[travis-ci.yml]</p>\n<p>*Note that the ssh keys for the production server must be <a href=\"https://travis-ci.com/ssh-keys\">encrypted</a>.</p>\n<p>Hopefully this helps someone else as there was less documentation out there than I expected when setting this up. Let me know how it goes below, thanks!</p>"}},{"node":{"frontmatter":{"friendlyName":"Two Opt Reciprocal Exchange","solverKey":"twoOptReciprocalExchange","type":"algorithm","class":"heuristic","defaults":{"showBestPath":false,"evaluatingDetailLevel":1,"maxEvaluatingDetailLevel":1}},"html":"<p>When deploying a set of services using docker-compose, it’s a good idea to have a separate repository to avoid cloning all of the code into your production environment.</p>\n<p>I finally got <a href=\"https://www.term.ninja\">termninja</a> set up correctly with continuous integration and docker-compose on digital ocean, and I thought I’d document the setup.</p>\n<h2>Production repository</h2>\n<p>A typical docker-compose project has a <code class=\"language-text\">docker-compose.yml</code> at the root of the project, and all of the code for the images as subfolders.</p>\n<p>[development folder structure]</p>\n<p>This works great for development - it’s easy to set up volumes and edit the code alongside the images. In production, however, it doesn’t make sense to clone the entire repository just to get to the docker-compose.yml file and start services.</p>\n<p>The solution I prefer is to have a separate repository set-up, in this case termninja-docker, that contains only the docker-compose.yml and any production specific configuration.</p>\n<p>[production folder structure]</p>\n<h2>Deployment</h2>\n<p>With this structure in place, deployments are accomplished using a container registry (like <a href=\"docker.com/hub\">docker hub</a>). It’s free to use for public images, and easy to push with docker-compose.</p>\n<p>The docker-compose.yml in both the development repo and the production repo should be setup to track the container registry.</p>\n<p>[tagged docker-compose]</p>\n<h2>Building and pushing images</h2>\n<p>Once the docker-compose.yml file is setup to track the appropriate image from the container registry, building images is simple.</p>\n<p><code class=\"language-text\">docker-compose build [service-name]</code></p>\n<p>Pushing the updated image is equally simple</p>\n<p><code class=\"language-text\">docker-compose push [service-name]</code></p>\n<h2>Pulling latest images</h2>\n<p>From the production environment, once the production docker-compose.yml is setup to track the container registry images, updating is simple</p>\n<p><code class=\"language-text\">docker-compose down</code>\n<code class=\"language-text\">docker-compose pull [service-name]</code>\n<code class=\"language-text\">docker-compose up</code></p>\n<p>All of this seems very intuitive, but I’ve come across several projects where deployments are setup to:\nclone the development repo\nbuild and start images</p>\n<p>This process is time consuming (more downtime) and results in unnecessary code residing on the server.</p>\n<h2>Continuous integration</h2>\n<p>Once this process is in place, I recommend setting up continuous integration to perform these functions automatically on every commit to the master branch in the development repo. </p>\n<p>A simplified travis-ci configuration from <a href=\"https://www.term.ninja\">termninja</a> is below. It performs the following steps on every commit.</p>\n<ol>\n<li>Clone the repository (automatic for travis)</li>\n<li>Login to docker hub using credentials provided through the <a href=\"https://www.travis-ci.com/environment\">travis environment</a> - <code class=\"language-text\">docker login</code></li>\n<li>Build the services - <code class=\"language-text\">docker-compose build games api</code></li>\n<li>Push the images - <code class=\"language-text\">docker-compose push games api</code></li>\n<li>Decrypt private production SSH key*</li>\n<li>SSH to production environmnet</li>\n<li>Stop services - <code class=\"language-text\">docker-compose down</code></li>\n<li>Pull updated images - <code class=\"language-text\">docker-compose pull games api</code></li>\n<li>Start service - <code class=\"language-text\">docker-compose up</code></li>\n</ol>\n<p>[travis-ci.yml]</p>\n<p>*Note that the ssh keys for the production server must be <a href=\"https://travis-ci.com/ssh-keys\">encrypted</a>.</p>\n<p>Hopefully this helps someone else as there was less documentation out there than I expected when setting this up. Let me know how it goes below, thanks!</p>"}}]}}}